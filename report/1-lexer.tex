\chapter{词法分析}
\section{设计概述}
    词法分析的任务是设计有限状态机，读取源代码并将其划分成一个个的终结符，即单词(Token)，并过滤注释。

    在具体实现方面，本编译器采用了正则表达式提前捕获组的方式提取并分割单词，具体步骤如下：
    \begin{enumerate}
        \item 首先对于每种单词，均构造一个正则表达式。\\例如\texttt{MAINTK\_P = "(?<MAINTK>main(?![a-zA-Z0-9\_]))"}。
            \\同时，对于空白符、单行注释和多行注释，也需要构造相应的正则表达式。
        \item 将每种单词的正则表达式连接起来，形成一个总体正则表达式，并分配进入第一个匹配的捕获组。
        \item 利用\texttt{Matcher.group}判断单词的类型，并获取具体单词内容即可。
    \end{enumerate}
    
    并且词法分析时，还需要得到单词的行号，为错误处理提供信息基础，本编译器通过记录读入到的\texttt{\ n}的数量来记录行号。

    最后经过词法分析，本编译器将得到一个包含所有单词的有序列表\texttt{List<Token>}，按照符合要求的方式输出即可。
\section{编码后的修改}
    采用正则表达式匹配的方法来进行词法分析较容易出错的点是捕获顺序，这个在设计时很容易忽略，在调试时发现。
    例如
    \begin{enumerate}
        \item \texttt{==}这类包括多个字符的单词应该排序在总体正则表达式靠前于\texttt{=}的位置，不然\texttt{==}会首先被\texttt{ASSIGN}捕获组捕获，从而得到两个\texttt{ASSIGN}而不是一个\texttt{EQL}
        \item \texttt{MAINTK}这类关键字同时也满足表示符的正则表达式，因此关键字的正则表达式应优先于表示符的正则表达式。
        \item 正则表达式还面临优化问题，过于复杂的正则表达式可能会造成栈溢出，例如对于多行注释的识别，
        若表达式为\texttt{"/*(.|$\backslash$ n|$\backslash$ r)*?*/"}，则会因为存在不确定的匹配导致在处理较长注释时，发生栈溢出错误，将表达式优化为\texttt{"/*[$\backslash$ s$\backslash$ S]*?*/"}消除不确定的匹配即可解决问题。
    \end{enumerate}
    
    这些问题在具体编码时随调试逐步完成正确。